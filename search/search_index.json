{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Conflict Collection","text":"<p>Data collection toolkit for Git merge conflicts: structural types, social signals, and similarity metrics.</p> <p><code>conflict-collection</code> builds on <code>conflict-parser</code> to let you:</p> <ul> <li>Enumerate and classify raw merge conflict cases (modify-modify, delete-modify, add-add, etc.)</li> <li>Capture rich 5\u2011tuple representations (A / B / O / M / R) suitable for ML datasets</li> <li>Extract social / ownership signals (recency, blame composition, prior integrator behaviour)</li> <li>Compute research-oriented metrics like the 3\u2011way anchored similarity ratio</li> </ul>"},{"location":"#why-this-exists","title":"Why this exists","text":"<p>Academic &amp; engineering studies of merge conflicts often re\u2011implement similar collection logic scattered across scripts. This project offers a typed, test\u2011covered, reusable core to standardise merge conflict data pipelines.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"Concept Description Conflict Case A single logical conflict instance (may aggregate multiple Git index stages) 5\u2011Tuple Ordered versions: ours (A), theirs (B), base/virtual base (O), conflicted (M), resolved (R) Social Signals Ownership &amp; recency meta-data helpful for predicting / understanding resolution difficulty Anchored Ratio A 3\u2011way normalised similarity score R vs R\u0302 relative to base O"},{"location":"#install","title":"Install","text":"<pre><code>pip install conflict-collection\n# or with docs extras\npip install conflict-collection[docs]\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Quick Start</li> <li>Conflict Type Collector</li> <li>Societal Signals Collector</li> <li>Anchored Ratio Metric</li> <li>Data Models</li> <li>API Reference</li> </ul>"},{"location":"#status","title":"Status","text":"<p>Beta. Interfaces may refine prior to 0.1. Feedback &amp; PRs welcome.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes will be documented here. The project adheres (loosely) to Semantic Versioning.</p>"},{"location":"changelog/#001-2025-08-26","title":"[0.0.1] - 2025-08-26","text":"<ul> <li>Initial alpha release: conflict type collector, societal signals, anchored ratio metric.</li> <li>MkDocs documentation scaffold with mkdocstrings.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for considering a contribution! Please help maintain a high signal-to-noise ratio.</p>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Fork &amp; create a feature branch</li> <li><code>pip install -e .[dev,docs]</code></li> <li>Add / adjust tests (keep coverage high)</li> <li>Format &amp; lint: <code>black . &amp;&amp; isort .</code></li> <li>Run tests: <code>pytest -q</code></li> <li>(Optional) Build docs locally: <code>mkdocs serve</code></li> <li>Submit PR with concise description &amp; motivation</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Use clear, conventional style prefixes when possible (<code>feat:</code>, <code>fix:</code>, <code>docs:</code>, <code>refactor:</code>). Keep the first line \u2264 72 chars.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Python \u2265 3.10 (structural typing, dataclasses, pattern matching OK)</li> <li>Prefer explicit over implicit; keep internal helpers underscored</li> <li>Document tricky algorithms with short rationale comments</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Target meaningful edge cases: empty conflicts, unusual delete/add combinations, large blame tables, insertion-heavy diffs.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Public APIs should have docstrings. If you add a module, add it to <code>mkdocs.yml</code> nav or an existing section.</p>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Maintainers will bump version in <code>pyproject.toml</code>, tag, and publish to PyPI. Changelog entries should accompany user-visible changes.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful and assume positive intent.</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This walks you through collecting conflict cases, social signals, and computing the anchored ratio.</p>"},{"location":"quickstart/#1-prepare-a-repo-in-a-conflicted-merge-state","title":"1. Prepare a repo in a conflicted merge state","text":"<p>You need a repository where <code>git merge &lt;branch&gt;</code> produced conflicts and stopped.</p> <pre><code># Example skeleton (simplified)\ngit clone &lt;your-repo&gt;\ncd &lt;your-repo&gt;\ngit checkout feature-A\ngit merge feature-B  # leaves conflicts\n</code></pre>"},{"location":"quickstart/#2-collect-typed-conflict-cases","title":"2. Collect typed conflict cases","text":"<pre><code>from conflict_collection.collectors.conflict_type import collect as collect_conflicts\n\ncases = collect_conflicts(repo_path=\".\", resolution_sha=\"&lt;post-resolution-commit-sha&gt;\")\nprint(len(cases), \"cases\")\nfirst = cases[0]\nprint(first.conflict_type, first.conflict_path)\n</code></pre> <p>Each element is a frozen dataclass such as <code>ModifyModifyConflictCase</code> with fields: <code>base_content</code>, <code>ours_content</code>, <code>theirs_content</code>, <code>conflict_body</code>, <code>resolved_body</code>, etc.</p>"},{"location":"quickstart/#3-social-ownership-signals","title":"3. Social / ownership signals","text":"<pre><code>from conflict_collection.collectors.societal import collect as collect_social\n\nsignals = collect_social(repo_path=\".\")  # dict[path -&gt; SocialSignalsRecord]\nfor path, record in signals.items():\n    print(path, record.ours_author, record.owner_commits_ours)\n</code></pre>"},{"location":"quickstart/#4-anchored-similarity-metric","title":"4. Anchored similarity metric","text":"<pre><code>from conflict_collection.metrics.anchored_ratio import anchored_ratio\n\nO = \"\"\"line1\\nline2\\nline3\"\"\"\nR = \"\"\"line1\\nX\\nline3\"\"\"\nR_hat = \"\"\"line1\\nY\\nline3\"\"\"\nscore = anchored_ratio(O, R, R_hat)\nprint(score)  # float in [0,1]\n</code></pre>"},{"location":"quickstart/#5-building-5tuples","title":"5. Building 5\u2011tuples","text":"<p>If you need the (A,B,O,M,R) representation for ML pipelines, convert a conflict case + raw merge config into a <code>Conflict5Tuple</code> (see model docs).</p>"},{"location":"quickstart/#6-reproducible-tests","title":"6. Reproducible tests","text":"<p>Clone this repo and run:</p> <pre><code>pip install -e .[dev]\npytest -q\n</code></pre>"},{"location":"quickstart/#7-next-steps","title":"7. Next steps","text":"<ul> <li>Explore the metrics</li> <li>Inspect auto-generated API Reference</li> <li>Contribute improvements (see Contributing)</li> </ul>"},{"location":"api/anchored_ratio_func/","title":"API: anchored_ratio","text":""},{"location":"api/collect_conflict_types/","title":"API: collect conflict types","text":""},{"location":"api/collect_conflict_types/#conflict_collection.collectors.conflict_type.collect","title":"collect","text":"<pre><code>collect(repo_path, resolution_sha, merge_config=None)\n</code></pre> <p>Collect typed merge conflict cases.</p> <p>Reads the raw unmerged index (<code>git ls-files -u</code>) and groups index stages (1=base, 2=ours, 3=theirs) into logical \"conflict families\". Each family is normalised into one of the dataclass variants from :mod:<code>conflict_collection.schema.typed_five_tuple</code>.</p> <p>Skips files that Git internally marks as conflicted but whose working tree contents no longer contain conflict markers (auto-resolved edge cases).</p> <p>Parameters:</p> Name Type Description Default <code>repo_path</code> <code>str</code> <p>Filesystem path to a Git repository currently in a merge-conflict state.</p> required <code>resolution_sha</code> <code>str</code> <p>Commit SHA representing the resolved state (used to retrieve final blob content).</p> required <code>merge_config</code> <code>Optional[MergeMetadata]</code> <p>Optional merge metadata (used to validate marker size / style).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ConflictCase]</code> <p>List of typed <code>ConflictCase</code> instances.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If expected blobs/paths are missing for a detected conflict shape.</p> Source code in <code>conflict_collection/collectors/conflict_type/collector.py</code> <pre><code>def collect(\n    repo_path: str, resolution_sha: str, merge_config: Optional[MergeMetadata] = None\n) -&gt; list[ConflictCase]:\n    \"\"\"Collect typed merge conflict cases.\n\n    Reads the raw unmerged index (``git ls-files -u``) and groups index stages\n    (1=base, 2=ours, 3=theirs) into logical \"conflict families\". Each family\n    is normalised into one of the dataclass variants from\n    :mod:`conflict_collection.schema.typed_five_tuple`.\n\n    Skips files that Git internally marks as conflicted but whose working tree\n    contents no longer contain conflict markers (auto-resolved edge cases).\n\n    Args:\n        repo_path: Filesystem path to a Git repository currently in a merge-conflict state.\n        resolution_sha: Commit SHA representing the resolved state (used to retrieve final blob content).\n        merge_config: Optional merge metadata (used to validate marker size / style).\n\n    Returns:\n        List of typed ``ConflictCase`` instances.\n\n    Raises:\n        ValueError: If expected blobs/paths are missing for a detected conflict shape.\n    \"\"\"\n    repo = Repo(repo_path)\n\n    # 1. group by \"conflict family\", or loosely speaking \"same file\"\n    groups = group_conflict_families(repo)\n\n    cases: list[ConflictCase] = []\n\n    # 3. build ConflictCase objects\n    for slot in groups.values():\n        found_stages = frozenset(slot.keys())\n\n        o_blob, o_path = slot.get(1, (None, None))\n        a_blob, a_path = slot.get(2, (None, None))\n        b_blob, b_path = slot.get(3, (None, None))\n\n        if found_stages == set({}):\n            raise ValueError(\n                \"No blobs found in conflict group. \"\n                \"This should not happen, please report a bug.\"\n            )\n\n        elif found_stages == {1}:\n            if o_blob is None or o_path is None:\n                raise ValueError(\n                    \"Delete-Delete conflict detected, but no base blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            cases.append(\n                DeleteDeleteConflictCase(\n                    base_path=str(o_path),\n                    ours_path=None,\n                    theirs_path=None,\n                    base_content=o_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    ours_content=None,\n                    theirs_content=None,\n                    conflict_path=str(o_path),\n                    conflict_body=None,\n                    resolved_path=None,\n                    resolved_body=None,\n                )\n            )\n\n        elif found_stages == {2}:\n            if a_blob is None or a_path is None:\n                raise ValueError(\n                    \"Added by us conflict detected, but no blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            resolved_path, resolved_body = read_blob(repo, resolution_sha, str(a_path))\n\n            cases.append(\n                AddedByUsConflictCase(\n                    base_path=None,\n                    ours_path=str(a_path),\n                    theirs_path=None,\n                    base_content=None,\n                    ours_content=a_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    theirs_content=None,\n                    conflict_path=str(a_path),\n                    conflict_body=read_worktree_file(repo, str(a_path)),\n                    resolved_path=resolved_path,\n                    resolved_body=resolved_body,\n                )\n            )\n\n        elif found_stages == {3}:\n            if b_blob is None or b_path is None:\n                raise ValueError(\n                    \"Added by them conflict detected, but no blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            resolved_path, resolved_body = read_blob(repo, resolution_sha, str(b_path))\n\n            cases.append(\n                AddedByThemConflictCase(\n                    base_path=None,\n                    ours_path=None,\n                    theirs_path=str(b_path),\n                    base_content=None,\n                    ours_content=None,\n                    theirs_content=b_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    conflict_path=str(b_path),\n                    conflict_body=read_worktree_file(repo, str(b_path)),\n                    resolved_path=resolved_path,\n                    resolved_body=resolved_body,\n                )\n            )\n\n        elif found_stages == {1, 2}:\n            if a_blob is None or a_path is None:\n                raise ValueError(\n                    \"Modify-Delete conflict detected, but no blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n            if o_blob is None or o_path is None:\n                raise ValueError(\n                    \"Modify-Delete conflict detected, but no base blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            # Figure out which branch was accepted\n            resolved_path, resolved_body = read_blob(repo, resolution_sha, str(a_path))\n\n            ours_content = a_blob.data_stream.read().decode(\"utf-8\", \"replace\")\n            cases.append(\n                ModifyDeleteConflictCase(\n                    base_path=str(o_path),\n                    ours_path=str(a_path),\n                    theirs_path=None,\n                    base_content=o_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    ours_content=ours_content,\n                    theirs_content=None,\n                    conflict_path=str(a_path),\n                    conflict_body=ours_content,\n                    resolved_path=resolved_path,\n                    resolved_body=resolved_body,\n                )\n            )\n\n        elif found_stages == {1, 3}:\n            if b_blob is None or b_path is None:\n                raise ValueError(\n                    \"Delete-Modify conflict detected, but no blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n            if o_blob is None or o_path is None:\n                raise ValueError(\n                    \"Delete-Modify conflict detected, but no base blob or path found. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            # Figure out which branch was accepted\n            resolved_path, resolved_body = read_blob(repo, resolution_sha, str(b_path))\n\n            theirs_content = b_blob.data_stream.read().decode(\"utf-8\", \"replace\")\n            cases.append(\n                DeleteModifyConflictCase(\n                    base_path=str(o_path),\n                    ours_path=None,\n                    theirs_path=str(b_path),\n                    base_content=o_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    ours_content=None,\n                    theirs_content=theirs_content,\n                    conflict_path=str(b_path),\n                    conflict_body=theirs_content,\n                    resolved_path=resolved_path,\n                    resolved_body=resolved_body,\n                )\n            )\n            continue\n\n        elif found_stages == {2, 3}:\n            if a_blob is None or a_path is None or b_blob is None or b_path is None:\n                raise ValueError(\n                    \"Add-Add conflict detected, but not all blobs or paths are present. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            # Figure out which branch was accepted\n            resolved_path, resolved_body = read_blob(repo, resolution_sha, str(a_path))\n            if resolved_path is None:\n                resolved_path, resolved_body = read_blob(\n                    repo, resolution_sha, str(b_path)\n                )\n\n            cases.append(\n                AddAddConflictCase(\n                    base_path=None,\n                    ours_path=str(a_path),\n                    theirs_path=str(b_path),\n                    base_content=None,\n                    ours_content=a_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    theirs_content=b_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    conflict_path=str(a_path),\n                    conflict_body=read_worktree_file(repo, str(a_path)),\n                    resolved_path=resolved_path,\n                    resolved_body=resolved_body,\n                )\n            )\n            continue\n\n        else:\n            if (\n                o_blob is None\n                or a_blob is None\n                or b_blob is None\n                or o_path is None\n                or a_path is None\n                or b_path is None\n            ):\n                raise ValueError(\n                    \"Modify-Modify conflict detected, but not all blobs or paths are present. \"\n                    \"This should not happen, please report a bug.\"\n                )\n\n            resolved_path, resolved_body = read_blob(repo, resolution_sha, str(a_path))\n            conflict_body = read_worktree_file(repo, str(a_path))\n            expected_header = \"&lt;\" * (\n                7 if merge_config is None else merge_config.marker_size\n            )\n            if (\n                not conflict_body.startswith(expected_header)\n                and (\"\\n\" + expected_header) not in conflict_body\n            ):\n                # If the conflict markers are not present, we assume the file was auto-resolved.\n                # NOTE: Refer to the bug explained in group_conflict_families() function.\n                continue\n\n            cases.append(\n                ModifyModifyConflictCase(\n                    base_path=str(o_path),\n                    ours_path=str(a_path),\n                    theirs_path=str(b_path),\n                    base_content=o_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    ours_content=a_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    theirs_content=b_blob.data_stream.read().decode(\"utf-8\", \"replace\"),\n                    conflict_path=str(a_path),\n                    conflict_body=conflict_body,\n                    resolved_path=resolved_path,\n                    resolved_body=resolved_body,\n                )\n            )\n\n    return cases\n</code></pre>"},{"location":"api/collect_societal_signals/","title":"API: collect societal signals","text":""},{"location":"api/collect_societal_signals/#conflict_collection.collectors.societal.collect","title":"collect","text":"<pre><code>collect(repo_path='.', files=None)\n</code></pre> <p>Collect ownership &amp; social signal metrics for conflicted files.</p> <p>By default operates on the set of currently conflicted files (from the in-progress merge). An explicit <code>files</code> iterable can be supplied to target arbitrary paths.</p> <p>Signals include recency (age in days), author commit counts since merge bases, integrator prior activity, and an aggregated blame table.</p> <p>Parameters:</p> Name Type Description Default <code>repo_path</code> <code>str</code> <p>Filesystem path to the repository (defaults to current directory).</p> <code>'.'</code> <code>files</code> <code>Optional[Iterable[str]]</code> <p>Optional iterable of repo-relative file paths; if omitted, only conflicted files are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, SocialSignalsRecord]</code> <p>Mapping of file path to :class:<code>SocialSignalsRecord</code>.</p> Source code in <code>conflict_collection/collectors/societal/collector.py</code> <pre><code>def collect(\n    repo_path: str = \".\",\n    files: Optional[Iterable[str]] = None,\n) -&gt; dict[str, SocialSignalsRecord]:\n    \"\"\"Collect ownership &amp; social signal metrics for conflicted files.\n\n    By default operates on the set of currently conflicted files (from the\n    in-progress merge). An explicit ``files`` iterable can be supplied to\n    target arbitrary paths.\n\n    Signals include recency (age in days), author commit counts since merge\n    bases, integrator prior activity, and an aggregated blame table.\n\n    Args:\n        repo_path: Filesystem path to the repository (defaults to current directory).\n        files: Optional iterable of repo-relative file paths; if omitted, only conflicted files are used.\n\n    Returns:\n        Mapping of file path to :class:`SocialSignalsRecord`.\n    \"\"\"\n    repo = Repo(repo_path)\n\n    file_list = list(files) if files else conflicted_files(repo)\n    if not file_list:\n        return {}\n\n    head_sha = rev_parse(repo, \"HEAD\")\n    merge_sha = rev_parse(repo, \"MERGE_HEAD\")\n    base_shas = merge_bases(repo, head_sha, merge_sha)\n    epoch_head = commit_epoch(repo, head_sha)\n    epoch_merge = commit_epoch(repo, merge_sha)\n    ref_ts = max(epoch_head, epoch_merge)\n\n    integrator = integrator_name(repo)\n\n    results: dict[str, SocialSignalsRecord] = {}\n    \"\"\"Mapping from file path to SocialSignalsRecord\"\"\"\n\n    for f in file_list:\n        ours_last = last_commit_for_path(repo, head_sha, f)\n        theirs_last = last_commit_for_path(repo, merge_sha, f)\n        if ours_last is None:\n            logging.error(\n                f\"Last commit for {f} not found on {repo} \"\n                f\"starting from commit hash {head_sha}. \"\n                \"Skipping file.\"\n            )\n            continue\n        if theirs_last is None:\n            logging.error(\n                f\"Last commit for {f} not found on {repo} \"\n                f\"starting from commit hash {merge_sha}. \"\n                \"Skipping file.\"\n            )\n            continue\n\n        ours_author = commit_author_str(ours_last)\n        theirs_author = commit_author_str(theirs_last)\n\n        owner_commits_ours = count_commits_by_author_since_bases(\n            repo, f, ours_author, base_shas, head_sha\n        )\n        owner_commits_theirs = count_commits_by_author_since_bases(\n            repo, f, theirs_author, base_shas, merge_sha\n        )\n\n        age_days_ours = age_days(ref_ts, ours_last)\n        age_days_theirs = age_days(ref_ts, theirs_last)\n\n        integrator_prev = (\n            count_commits_by_author(repo, f, integrator) if integrator else 0\n        )\n\n        blame_pairs = blame_aggregate(repo, head_sha, f)\n        blame_table = [BlameEntry(author=a, lines=n) for a, n in blame_pairs]\n\n        results[f] = SocialSignalsRecord(\n            file=f,\n            ours_author=ours_author,\n            theirs_author=theirs_author,\n            owner_commits_ours=owner_commits_ours,\n            owner_commits_theirs=owner_commits_theirs,\n            age_days_ours=age_days_ours,\n            age_days_theirs=age_days_theirs,\n            integrator_priors=IntegratorPriors(resolver_prev_commits=integrator_prev),\n            blame_table=sorted(blame_table, key=lambda b: b.lines, reverse=True),\n        )\n\n    return results\n</code></pre>"},{"location":"api/five_tuple_model/","title":"API: five_tuple","text":""},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Conflict5Tuple']\n</code></pre>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple","title":"Conflict5Tuple","text":"<p>               Bases: <code>BaseModel</code></p> <p>Merge Conflict represented in a 5-tuple structure. Contains the 5 necessary versions of a conflicting file (A, B, O, M, R).</p>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre> <p>(O) Content of the 'base' version in the merge conflict.</p> <p>NOTE: In case of diverging history merges, this content may be a virtual base. Git defaults to creating a virtual base, an amalgamation of all qualifying bases, in case of multiple base merges.</p> <p>NOTE: Virtual bases do NOT match any single committed version.</p>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple.conflict_content","title":"conflict_content  <code>instance-attribute</code>","text":"<pre><code>conflict_content\n</code></pre> <p>(M) Content of the merge conflict, expected to include conflict markers.</p>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple.merge_config","title":"merge_config  <code>instance-attribute</code>","text":"<pre><code>merge_config\n</code></pre> <p>Configurations used for this merge conflict.</p> <p>Reference Git - merge-config Documentation</p>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre> <p>(A) Content of the 'ours' version in the merge conflict.</p>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple.resolved_content","title":"resolved_content  <code>instance-attribute</code>","text":"<pre><code>resolved_content\n</code></pre> <p>(R) Content of the resolved merge conflict.</p>"},{"location":"api/five_tuple_model/#conflict_collection.schema.five_tuple.Conflict5Tuple.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre> <p>(B) Content of the 'theirs' version in the merge conflict.</p>"},{"location":"api/social_signals_models/","title":"API: social_signals","text":"<p>Data models for social signals captured from a Git repository.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['BlameEntry', 'IntegratorPriors', 'SocialSignalsRecord']\n</code></pre>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.BlameEntry","title":"BlameEntry","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.BlameEntry.author","title":"author  <code>instance-attribute</code>","text":"<pre><code>author\n</code></pre> <p>Author name or email as attributed by <code>git blame</code>.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.BlameEntry.lines","title":"lines  <code>instance-attribute</code>","text":"<pre><code>lines\n</code></pre> <p>Number of lines attributed to this author in the blamed revision.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.IntegratorPriors","title":"IntegratorPriors","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.IntegratorPriors.resolver_prev_commits","title":"resolver_prev_commits  <code>instance-attribute</code>","text":"<pre><code>resolver_prev_commits\n</code></pre> <p>Number of prior commits by the current integrator touching this file.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord","title":"SocialSignalsRecord","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.age_days_ours","title":"age_days_ours  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>age_days_ours = None\n</code></pre> <p>Age in days of our most recent commit for this file (relative to the newer of HEAD/MERGE_HEAD).</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.age_days_theirs","title":"age_days_theirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>age_days_theirs = None\n</code></pre> <p>Age in days of their most recent commit for this file (relative to the newer of HEAD/MERGE_HEAD).</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.blame_table","title":"blame_table  <code>instance-attribute</code>","text":"<pre><code>blame_table\n</code></pre> <p>Aggregated blame table at <code>HEAD</code>, grouped by author.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file\n</code></pre> <p>Repo-relative path to the conflicted file.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.integrator_priors","title":"integrator_priors  <code>instance-attribute</code>","text":"<pre><code>integrator_priors\n</code></pre> <p>Per-integrator priors capturing local resolver behavior.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.ours_author","title":"ours_author  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ours_author = None\n</code></pre> <p>Author of the most recent commit touching this file on our side (HEAD).</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.owner_commits_ours","title":"owner_commits_ours  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>owner_commits_ours = 0\n</code></pre> <p>Count of commits authored by <code>ours_author</code> in <code>merge-base..HEAD</code> for this file.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.owner_commits_theirs","title":"owner_commits_theirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>owner_commits_theirs = 0\n</code></pre> <p>Count of commits authored by <code>theirs_author</code> in <code>merge-base..MERGE_HEAD</code> for this file.</p>"},{"location":"api/social_signals_models/#conflict_collection.schema.social_signals.SocialSignalsRecord.theirs_author","title":"theirs_author  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theirs_author = None\n</code></pre> <p>Author of the most recent commit touching this file on their side (MERGE_HEAD).</p>"},{"location":"api/typed_five_tuple_models/","title":"API: typed_five_tuple","text":""},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ALL_CONFLICT_TYPES","title":"ALL_CONFLICT_TYPES  <code>module-attribute</code>","text":"<pre><code>ALL_CONFLICT_TYPES = ['modify_modify', 'added_by_us', 'added_by_them', 'delete_modify', 'modify_delete', 'delete_delete', 'add_add']\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ConflictCase","title":"ConflictCase  <code>module-attribute</code>","text":"<pre><code>ConflictCase = Union[DeleteDeleteConflictCase, AddedByUsConflictCase, AddedByThemConflictCase, ModifyDeleteConflictCase, DeleteModifyConflictCase, ModifyModifyConflictCase, AddAddConflictCase]\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DELETE_TOKEN","title":"DELETE_TOKEN  <code>module-attribute</code>","text":"<pre><code>DELETE_TOKEN = '\u203dDELETED\u203d'\n</code></pre> <p>Indicate that a file was deleted in a commit. Interrobang punctuation is used to avoid confusion with real file contents.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.T_ALL_CONFLICT_TYPES","title":"T_ALL_CONFLICT_TYPES  <code>module-attribute</code>","text":"<pre><code>T_ALL_CONFLICT_TYPES = Literal['modify_modify', 'added_by_us', 'added_by_them', 'delete_modify', 'modify_delete', 'delete_delete', 'add_add']\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ModifyModifyConflictCase', 'AddedByUsConflictCase', 'AddedByThemConflictCase', 'DeleteModifyConflictCase', 'ModifyDeleteConflictCase', 'DeleteDeleteConflictCase', 'AddAddConflictCase', 'ConflictCase', 'ALL_CONFLICT_TYPES', 'T_ALL_CONFLICT_TYPES', 'DELETE_TOKEN']\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase","title":"AddAddConflictCase  <code>dataclass</code>","text":"<pre><code>AddAddConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='add_add')\n</code></pre> <p>Represents a merge conflict where a file has been added in both branches. From the human perspective, this happens when there's a rename-rename. Git will show this as a delete-delete conflict, followed by an add by us and an add by them.</p> <p>NOTE: This conflict can generate two conflicting files with the same content in two different paths.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre> <p>The content of the file as it exists in the working tree, with conflict markers.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre> <p>In the add-add case, this is our path.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'add_add'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddAddConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase","title":"AddedByThemConflictCase  <code>dataclass</code>","text":"<pre><code>AddedByThemConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='added_by_them')\n</code></pre> <p>Represents a merge conflict where the base file has been added on their side but conflicts.</p> <p>Potentially one of the rarest forms of merge conflicts. From the human perspective it happens when one side adds a new file, but the other side moved the directory the file was added to, and then something goes wrong with the merge.</p> <p>Git will show this as an \"added by them\" conflict.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre> <p>The contents of this file will NOT contain conflict markers, because it is a new file that was added in one side.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'added_by_them'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByThemConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase","title":"AddedByUsConflictCase  <code>dataclass</code>","text":"<pre><code>AddedByUsConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='added_by_us')\n</code></pre> <p>Represents a merge conflict where the base file has been added on our side but conflicts.</p> <p>Potentially one of the rarest forms of merge conflicts. From the human perspective it happens when one side adds a new file, but the other side moved the directory the file was added to, and then something goes wrong with the merge.</p> <p>Git will show this as an \"added by us\" conflict.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre> <p>The contents of this file will NOT contain conflict markers, because it is a new file that was added in one side.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'added_by_us'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.AddedByUsConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase","title":"DeleteDeleteConflictCase  <code>dataclass</code>","text":"<pre><code>DeleteDeleteConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='delete_delete')\n</code></pre> <p>Represents a merge conflict where the base file has been deleted from both sides. From the human perspective, this happens when there's a rename-rename. Git will show this as a delete-delete conflict, followed by an add by us and an add by them.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre> <p>In the delete-delete case, this is just base_path.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'delete_delete'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteDeleteConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase","title":"DeleteModifyConflictCase  <code>dataclass</code>","text":"<pre><code>DeleteModifyConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='delete_modify')\n</code></pre> <p>Represents a merge conflict where the base file has been deleted from our side, and modified on their branch.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre> <p>As our content is deleted, this is just base_path.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'delete_modify'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre> <p>The resolution may be a deleted file, in which case this is None.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.DeleteModifyConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase","title":"ModifyDeleteConflictCase  <code>dataclass</code>","text":"<pre><code>ModifyDeleteConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='modify_delete')\n</code></pre> <p>Represents a merge conflict where the base file has been deleted from their side, and modified on our branch.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre> <p>As their content is deleted, this is just ours_path.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'modify_delete'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre> <p>The resolution may be a deleted file, in which case this is None.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyDeleteConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase","title":"ModifyModifyConflictCase  <code>dataclass</code>","text":"<pre><code>ModifyModifyConflictCase(base_path, ours_path, theirs_path, base_content, ours_content, theirs_content, conflict_path, conflict_body, resolved_path, resolved_body, conflict_type='modify_modify')\n</code></pre> <p>Represents a single merge conflict case with all relevant file contents.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.base_content","title":"base_content  <code>instance-attribute</code>","text":"<pre><code>base_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.conflict_body","title":"conflict_body  <code>instance-attribute</code>","text":"<pre><code>conflict_body\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.conflict_path","title":"conflict_path  <code>instance-attribute</code>","text":"<pre><code>conflict_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.conflict_type","title":"conflict_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_type = 'modify_modify'\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.ours_content","title":"ours_content  <code>instance-attribute</code>","text":"<pre><code>ours_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.ours_path","title":"ours_path  <code>instance-attribute</code>","text":"<pre><code>ours_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.resolved_body","title":"resolved_body  <code>instance-attribute</code>","text":"<pre><code>resolved_body\n</code></pre> <p>The resolution may be a deleted file, in which case it will be the special DELETE_TOKEN.</p>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.resolved_path","title":"resolved_path  <code>instance-attribute</code>","text":"<pre><code>resolved_path\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.theirs_content","title":"theirs_content  <code>instance-attribute</code>","text":"<pre><code>theirs_content\n</code></pre>"},{"location":"api/typed_five_tuple_models/#conflict_collection.schema.typed_five_tuple.ModifyModifyConflictCase.theirs_path","title":"theirs_path  <code>instance-attribute</code>","text":"<pre><code>theirs_path\n</code></pre>"},{"location":"collectors/conflict_types/","title":"Conflict Type Collection","text":"<p>The conflict type collector reads the unmerged index (<code>git ls-files -u</code>) and groups related index entries into cohesive conflict \"families\". Each family is normalised into one of the typed dataclasses defined in <code>typed_five_tuple</code>.</p>"},{"location":"collectors/conflict_types/#usage","title":"Usage","text":"<pre><code>from conflict_collection.collectors.conflict_type import collect\n\ncases = collect(repo_path=\".\", resolution_sha=\"&lt;resolved-commit-sha&gt;\")\nfor c in cases:\n    print(c.conflict_type, c.conflict_path)\n</code></pre>"},{"location":"collectors/conflict_types/#returned-types","title":"Returned Types","text":"<ul> <li><code>ModifyModifyConflictCase</code></li> <li><code>ModifyDeleteConflictCase</code></li> <li><code>DeleteModifyConflictCase</code></li> <li><code>DeleteDeleteConflictCase</code></li> <li><code>AddedByUsConflictCase</code></li> <li><code>AddedByThemConflictCase</code></li> <li><code>AddAddConflictCase</code></li> </ul> <p>All cases share the semantic fields: paths, per-side contents, conflict body (with markers when applicable), and resolution information.</p>"},{"location":"collectors/conflict_types/#edge-cases-notes","title":"Edge Cases &amp; Notes","text":"<ul> <li>Auto-resolved files (Git considers them conflicted internally but markers removed) are skipped.</li> <li>Delete / add sequencing in rename-rename scenarios surfaces as multiple cases (<code>delete_delete</code> \u2192 <code>added_by_us</code> \u2192 <code>added_by_them</code>).</li> <li><code>resolution_sha</code> should be the commit after you have resolved conflicts (or any commit providing the final file blobs for comparison). If the resolution isn't committed yet, you can create a WIP commit or adapt the reader to inspect the worktree directly.</li> </ul>"},{"location":"collectors/conflict_types/#api-reference","title":"API Reference","text":"<p>See the auto-generated API docs: collector function.</p>"},{"location":"collectors/societal/","title":"Societal / Ownership Signals","text":"<p>Captures developer-centric signals for conflicted files to support studies of ownership, expertise, and recency.</p>"},{"location":"collectors/societal/#signals-collected","title":"Signals Collected","text":"Field Meaning <code>ours_author</code> / <code>theirs_author</code> Last commit authors touching the file on each side <code>owner_commits_ours</code> / <code>_theirs</code> Count of commits by the side's latest author since the merge base(s) <code>age_days_ours</code> / <code>_theirs</code> Age (days) of last modification relative to merge reference time <code>integrator_priors.resolver_prev_commits</code> Historical commits by the integrator to this file <code>blame_table</code> Aggregated blame at <code>HEAD</code> grouped by author"},{"location":"collectors/societal/#usage","title":"Usage","text":"<pre><code>from conflict_collection.collectors.societal import collect\n\nsignals = collect(repo_path=\".\")\nfor path, rec in signals.items():\n    print(path, rec.ours_author, rec.owner_commits_ours, rec.age_days_ours)\n</code></pre>"},{"location":"collectors/societal/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Merge bases are computed (could be &gt;1). Ownership counts exclude commits before all bases.</li> <li>File list defaults to currently conflicted files; pass an explicit iterable to target arbitrary files.</li> <li>Blame aggregation collapses contiguous regions by author and sums line counts.</li> </ul>"},{"location":"collectors/societal/#api-reference","title":"API Reference","text":"<p>See collector function.</p>"},{"location":"metrics/anchored_ratio/","title":"Anchored Ratio","text":"<p>A 3\u2011way similarity metric <code>anchored_ratio(O, R, R_hat)</code> producing a score in [0,1] comparing two edited versions (R, R\u0302) relative to a base O.</p> <ul> <li>Denominator normalises over the union of changed base intervals plus insertion slots.</li> <li>Numerator rewards aligned equal lines (and optionally per-line Levenshtein similarity) within each union block and insertion slot.</li> </ul> <pre><code>from conflict_collection.metrics.anchored_ratio import anchored_ratio\nscore = anchored_ratio(O, R, R_hat, use_line_levenshtein=True)\n</code></pre> <p>If neither side changes anything (no base changes, no insertions) the score is defined as 1.0.</p>"},{"location":"metrics/anchored_ratio/#when-to-use","title":"When to Use","text":"<p>Useful for measuring convergence of independent resolution attempts, or similarity between automated and manual merges.</p>"},{"location":"metrics/anchored_ratio/#rationale","title":"Rationale","text":"<p>Traditional pairwise diffs ignore the role of the base. Anchoring both transformations to O allows fairer comparison of expansion/compression asymmetries and insertion slots.</p>"},{"location":"metrics/anchored_ratio/#api","title":"API","text":"<p>See function reference.</p>"},{"location":"models/five_tuple/","title":"Conflict 5\u2011Tuple Model","text":"<p><code>Conflict5Tuple</code> captures the canonical five versions involved in a merge conflict:</p> Symbol Field Description A <code>ours_content</code> Our side's version B <code>theirs_content</code> Their side's version O <code>base_content</code> Base (possibly virtual) version M <code>conflict_content</code> File content with Git conflict markers R <code>resolved_content</code> Post-resolution version (may be absent)"},{"location":"models/five_tuple/#usage","title":"Usage","text":"<pre><code>from conflict_collection.schema.five_tuple import Conflict5Tuple\nfrom conflict_parser import MergeMetadata\n\nrecord = Conflict5Tuple(\n    ours_content=\"...\",\n    theirs_content=\"...\",\n    base_content=\"...\",\n    conflict_content=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\\n...=======\\n...&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch\\n\",\n    resolved_content=None,\n    merge_config=MergeMetadata(conflict_style=\"merge\"),\n)\n</code></pre> <p>The model is a Pydantic <code>BaseModel</code> for validation and serialisation.</p>"},{"location":"models/social_signals/","title":"Social Signals Models","text":"<p>Pydantic models describing ownership &amp; activity signals for conflicted files.</p> <ul> <li><code>SocialSignalsRecord</code></li> <li><code>BlameEntry</code></li> <li><code>IntegratorPriors</code></li> </ul> <p>See full reference: social signals.</p>"},{"location":"models/typed_conflict_cases/","title":"Typed Conflict Cases","text":"<p>Immutable dataclasses (frozen, slots) describing concrete conflict manifestations. All variants share the conceptual fields: paths, contents per side, the conflict body, and resolution metadata (path/content may be deleted).</p> <p>Variants:</p> <ul> <li><code>ModifyModifyConflictCase</code></li> <li><code>ModifyDeleteConflictCase</code></li> <li><code>DeleteModifyConflictCase</code></li> <li><code>DeleteDeleteConflictCase</code></li> <li><code>AddedByUsConflictCase</code></li> <li><code>AddedByThemConflictCase</code></li> <li><code>AddAddConflictCase</code></li> </ul> <p>Each exposes a <code>conflict_type</code> literal string suitable for grouping.</p> <p>See full auto-generated reference: typed cases.</p>"}]}